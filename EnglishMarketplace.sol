//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @title EnglishMarketplace
 * @author @brougkr
 * @notice A Smart Contract To Facilitate Ascending Rebate Auctions (With Ascending Rebate Reserve Floor) For Multiple NFTs (Or Whatever Else You Want To Sell)
 */
pragma solidity 0.8.19;
import {MissionControl} from "./MissionControl.sol";
import {DelegateCashEnabled} from "./DelegateCashEnabled.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract EnglishMarketplace is
    MissionControl,
    DelegateCashEnabled,
    ReentrancyGuard
{
    struct Bid {
        uint _OGBidIndex; // [0] -> Original Bid Index
        uint _Priority; // [1] -> Priority Of Bid (Merkle Rank)
        uint _Allocation; // [2] -> Allocation For Provided Priority Tier
        uint _ETHValue; // [3] -> ETH Value Of Bid
        uint _Timestamp; // [4] -> Unix Timestamp Of Bid Confirmation
        address _Bidder; // [5] -> Wallet Address Of Bidder
        address _Vault; // [6] -> Wallet Address Of Vault (optional `delegate.cash` support)
        bool _Rebated; // [7] -> If Bidder Rebated ETH From Bid
        bool _Winner; // [8] -> If Bidder Is A Winner (Top Placing) In The Auction
        bool _NFTSent; // [9] -> If Bidder Has Received Their NFT
    }

    struct Params {
        string _Name; // [0] -> Name Of Auction
        bool _SettlementEnabled; // [1] -> If Rebate Last Price Is Enabled (Everyone Pays Lowest Leaderboard Price)
        bool _UserSettlementEnabled; // [2] -> If Self-Service User Settlement Is Enabled (Bidders Can Settle Their Own Bids ETH & NFTs)
        uint _LeaderboardSize; // [3] -> The Bid Threshold For NewMinimumBid (eg. 50 Valid Bids)
        uint _UnixStartTime; // [4] -> Unix Start Time Of Auction
        uint _UnixEndTime; // [5] -> Unix End Time Of Auction
        uint _MinBIPSIncrease; // [6] -> Minimum BIPS (%) Increase On Each Subsequent Bid After Configured LeaderboardSize
        uint _SecondsExtension; // [7] -> # Of Second(s) Of Extension For Auction (Input In Seconds)
        uint _SecondsThreshold; // [8] -> # Of Seconds Within Auction End Time To Be Eligible For Auction Extension
        uint _InitialMinimumBid; // [9] -> Initial Minimum Bid
        uint _ProjectIDMintPass; // [10] -> The Factory MintPass ProjectID
        uint _MintPackAmount; // [11] -> The Amount Of Mint Passes To Disperse Per Bid
        address _NFT; // [12] -> Address Of NFT Contract
        address _Operator; // [13] -> Wallet Holding NFTs To Disperse
    }

    struct State {
        bool _Active; // [0] -> _Active
        bool _NFTsDispersed; // [1] -> _NFTsDispersed
        uint _LastMinBid; // [2] -> _LastMinBid
        uint _GlobalUniqueBids; // [3] -> _GlobalUniqueBids
    }

    struct AllAuctionParams {
        string _Name; // [0] -> Name Of Auction
        bool _Active; // [1] -> If Sale Is Active
        bool _NFTsDispersed; // [2] -> If NFTs Have Been Dispersed
        bool _SettlementEnabled; // [3] -> If Rebate Last Price Is Enabled (Everyone Pays Lowest Leaderboard Price)
        uint _LeaderboardSize; // [4] -> The Bid Threshold For NewMinimumBid (eg. 50 Valid Bids)
        uint _UnixStartTime; // [5] -> Unix Start Time Of Auction
        uint _UnixEndTime; // [6] -> Unix End Time Of Auction
        uint _MinBIPSIncrease; // [7] -> Minimum BIPS (%) Increase On Each Subsequent Bid After 50 Unique Bids
        uint _SecondsExtension; // [8] -> # Of Seconds(s) Of Extension For Auction (Input In # Of Seconds)
        uint _SecondsThreshold; // [9] -> # Of Seconds Within Auction End Time To Be Eligible For Auction Extension
        uint _LastMinBid; // [10] -> Value Of The Last Minimum Bid
        uint _GlobalUniqueBids; // [11] -> # Of Global Unique Bids
        uint _ProjectIDMintPass; // [12] -> The Factory MintPass ProjectID
        uint _MintPackAmount; // [13] -> The Amount Of Mint Passes To Disperse Per Bid
        address _NFT; // [14] -> Address Of NFT Contract
    }

    /*-----------
     * MAPPINGS *
    ------------*/

    mapping(uint => Params) public AuctionParams; // [SaleIndex] => Auction Params
    mapping(uint => State) public SaleState; // [SaleIndex] => Sale State
    mapping(uint => mapping(uint => Bid)) public Bids; // [SaleIndex][BidIndex] => Bid
    mapping(uint => mapping(uint => uint)) public Leaderboard; // [SaleIndex][LeaderboardIndex] => BidIndex
    mapping(uint => mapping(address => uint[])) public UserBidIndexes; // [SaleIndex][Wallet] => BidIndexes
    mapping(uint => mapping(uint => bool)) public NFTTokenIDHasBeenSent; // [SaleIndex][TokenID] => HasBeenSent
    mapping(uint => uint[]) public Discounts; // [SaleIndex] => Discount Amounts
    mapping(uint => bytes32[]) public MerkleRootsEligibility; // [SaleIndex] => Merkle Roots For Priority Eligibility
    mapping(uint => bytes32[]) public MerkleRootsAmounts; // [SaleIndex] => Merkle Roots For Priority Allocation
    mapping(uint => mapping(address => mapping(uint => uint)))
        public PriorityPurchaseAmount; // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level

    /*------------------
     * STATE VARIABLES *
    -------------------*/

    address private constant _BRT_MULTISIG =
        0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700; // `sales.brightmoments.eth`
    uint public _GLOBAL_UNIQUE_SALES = 1; // Global Unique Sales

    /*---------
     * EVENTS *
    ----------*/

    /**
     * @dev Emitted When A New Bid Is Submitted
     * @param SaleIndex The Sale Index
     * @param BidIndex The Bid Index
     * @param Bidder The Bidder
     * @param MessageValue The Amount Of ETH Sent
     * @param Unixtimestamp The Unix Timestamp
     * @param Vault The Vault Address (optional `delegate.cash` support)
     */
    event NewBidComplete(
        uint SaleIndex,
        uint BidIndex,
        address Bidder,
        uint MessageValue,
        uint Unixtimestamp,
        address Vault
    );

    /**
     * @dev Emitted When A Bid Is Topped Up
     * @param SaleIndex The Sale Index
     * @param BidIndex The Bid Index
     * @param ETHForBid The Amount Of ETH Topped Up
     * @param Unixtimestamp The Unix Timestamp
     * @param Bidder The Bidder
     */
    event BidToppedUp(
        uint SaleIndex,
        uint BidIndex,
        uint ETHForBid,
        uint Unixtimestamp,
        address Bidder
    );

    /**
     * @dev Emitted When A Bid Reclaim Fails
     * @param BidIndex The Bid Index
     */
    event BidReclaimFailed(uint BidIndex);

    /**
     * @dev Emitted When A Bid Reclaim Succeeds
     * @param BidIndex The Bid Index
     */
    event BidReclaimSuccess(uint BidIndex);

    /**
     * @dev Emitted When A Bidder's ETH Is Rebated (The Bid They Are Trying To Top Up Was Frontran)
     * @param Rebate The Amount Of ETH Rebated
     */
    event BidTopupRefunded(uint Rebate);

    /**
     * @dev Emitted When The Auction End Time Is Extended
     */
    event AuctionExtended();

    /**
     * @dev Emitted When A Bid Is Refunded (Kicked Back To Losing Bidder)
     * @param BidIndex The Bid Index
     */
    event BidRefunded(uint BidIndex);

    /**
     * @dev Emitted When A Sale Is Started
     * @param SaleIndex The Sale Index
     */
    event SaleStarted(uint SaleIndex);

    constructor() {
        _OWNER = msg.sender;
        SaleState[0]._Active = true; // activates auction
        SaleState[0]._LastMinBid = 0.0001 ether; // starts auction specified ETH value
        AuctionParams[0]._Name = "Golden Token Venice"; // sets auction name
        AuctionParams[0]._SettlementEnabled = true; // enables rebate last price
        AuctionParams[0]._LeaderboardSize = 1; // (max # of bids on leaderboard)
        AuctionParams[0]._UnixStartTime = block.timestamp; // sets auction start time
        AuctionParams[0]._UnixEndTime =
            AuctionParams[0]._UnixStartTime +
            86400 seconds; // sets auction end time 1 day after start
        AuctionParams[0]._MinBIPSIncrease = 110; // The Increase On Each Subsequent Bid After 50 Unique Bids
        AuctionParams[0]._SecondsExtension = 600 seconds; // # Of Seconds Of Extension
        AuctionParams[0]._SecondsThreshold = 600 seconds; // # Of Seconds Within Auction End Time Where Auction Extension Is Enabled
        AuctionParams[0]._InitialMinimumBid = 0.0001 ether; // sets initial minimum bid
    }

    /*-----------------
     * USER FUNCTIONS *
    ------------------*/

    /**
     * @dev Submits A New Bid To The Auction
     * @param SaleIndex The Sale Index To Target
     * @param MaxAmount The Maximum Merkle Priority Allocation Amount | note: Input 0 If Not Applicable
     * @param Vault Optional delegate.xyz Integration | note: Input 0x0000000000000000000000000000000000000000 If No Delegate
     * @param ProofEligibility The Merkle Proof For The Bidder's Priority | note: Input [0x0000000000000000000000000000000000000000000000000000000000000000] If No Merkle Proof
     * @param ProofAmount The Merkle Proof For The Bidder's Priority Allocation | note: Input [0x0000000000000000000000000000000000000000000000000000000000000000] If No Merkle Proof
     */
    function NewBid(
        uint SaleIndex,
        uint MaxAmount,
        address Vault,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) external payable nonReentrant {
        require(
            tx.origin == msg.sender,
            "EnglishAuction: EOA Only, Use `delegate.cash` For Wallet Delegation"
        ); // Requires `msg.sender` Is A Valid EOA
        require(
            SaleState[SaleIndex]._Active,
            "EnglishAuction: Auction Is Not Active"
        ); // Requires The Auction Is Active
        require(
            block.timestamp >= AuctionParams[SaleIndex]._UnixStartTime,
            "EnglishAuction: Auction Has Not Started"
        ); // Requires The Auction Has Started
        require(
            block.timestamp < AuctionParams[SaleIndex]._UnixEndTime,
            "EnglishAuction: Auction Has Concluded"
        ); // Requires The Auction Has Not Ended
        address Recipient = msg.sender;
        if (Vault != address(0)) {
            if (DelegateCash.checkDelegateForAll(msg.sender, Vault)) {
                Recipient = Vault;
            }
        } // `delegate.cash` Integration
        __FinalizeNewBid(SaleIndex, msg.value); // Auto-Calculates The Required Reserve Price For The Bid
        __CheckAndSeedAuctionEndTime(SaleIndex); // Checks If Auction End Time Should Be Extended And Extends If Necessary
        uint Priority = _ValidateMerkleProofs(
            SaleIndex,
            MaxAmount,
            Recipient,
            ProofEligibility,
            ProofAmount
        ); // Validates Merkle Proof And Returns Merkle Priority
        uint CurrentBidIndex = SaleState[SaleIndex]._GlobalUniqueBids; // Current Bid Index
        Bids[SaleIndex][CurrentBidIndex] = Bid(
            CurrentBidIndex, // [0] -> Original Bid Index
            Priority, // [1] -> Priority Of Bid (Merkle Rank)
            MaxAmount, // [2] -> Allocation For Provided Priority Tier
            msg.value, // [3] -> ETH Value Of Bid
            block.timestamp, // [4] -> Unix Timestamp Of Bid Confirmation
            msg.sender, // [5] -> Wallet Address Of Bidder
            Recipient, // [6] -> Wallet Address Of Vault (optional `delegate.cash` support)
            false, // [7] -> If Bidder Rebated ETH From Bid
            false, // [8] -> If Bidder Is A Winner (Top Placing) In The Auction
            false // [9] -> If Bidder Has Received Their NFT
        ); // Registers New Bid
        UserBidIndexes[SaleIndex][msg.sender].push(CurrentBidIndex); // Appends Bid Index To User's Bid Indexes
        SaleState[SaleIndex]._GlobalUniqueBids = CurrentBidIndex + 1; // Increments Global Unique Bids
        emit NewBidComplete(
            SaleIndex,
            CurrentBidIndex,
            msg.sender,
            msg.value,
            block.timestamp,
            Recipient
        ); // Emits Bid Event
    }

    /**
     * @dev Tops Up Bid(s) With Additional ETH
     * @param SaleIndex The Sale Index To Target
     * @param BidIndexes[] The Bid Indexes To Top Up
     * @param Amounts[] The Amounts (In WEI) To Top Up The Corresponding Bid Indexes By
     */
    function IncreaseBid(
        uint SaleIndex,
        uint[] calldata BidIndexes,
        uint[] calldata Amounts
    ) external payable nonReentrant {
        require(
            tx.origin == msg.sender,
            "EnglishAuction: EOA Only, Use `delegate.cash` For Wallet Delegation"
        ); // Requires `msg.sender` Is A Valid EOA
        require(
            SaleState[SaleIndex]._Active,
            "EnglishAuction: Auction Is Not Active"
        ); // Requires The Auction Is Active
        require(
            block.timestamp >= AuctionParams[SaleIndex]._UnixStartTime,
            "EnglishAuction: Auction Has Not Started"
        ); // Requires The Auction Has Started
        require(
            block.timestamp < AuctionParams[SaleIndex]._UnixEndTime,
            "EnglishAuction: Auction Has Concluded"
        ); // Requires The Auction Has Not Ended
        require(
            BidIndexes.length == Amounts.length,
            "EnglishAuction: BidIndexes And Amounts Array Length Mismatch"
        ); // Requires BidIndexes And Amounts Length Match
        require(
            BidIndexes.length > 0,
            "EnglishAuction: User Has Input No Bids To Top Up"
        ); // Requires User Has Bids To Top Up
        if (!AuctionParams[SaleIndex]._SettlementEnabled) {
            __CheckAndSeedAuctionEndTime(SaleIndex);
        } // Checks If Auction End Time Should Be Extended And Extends If Necessary
        Bid memory _Bid;
        uint Total;
        uint BidValue;
        for (uint x; x < BidIndexes.length; x++) {
            _Bid = Bids[SaleIndex][BidIndexes[x]];
            BidValue = _Bid._ETHValue;
            if (!_Bid._Rebated && !_Bid._Winner) {
                require(
                    msg.sender == _Bid._Bidder,
                    "EnglishAuction: `msg.sender` Is Not The Bidder Of Desired Bid Index"
                );
                require(
                    BidValue + Amounts[x] >=
                        (BidValue * AuctionParams[SaleIndex]._MinBIPSIncrease) /
                            100,
                    "EnglishAuction: Bid Amount Topup Requires >= 5% Increase"
                );
                Bids[SaleIndex][BidIndexes[x]]._ETHValue += Amounts[x];
                Bids[SaleIndex][BidIndexes[x]]._Timestamp = block.timestamp;
                Total += Amounts[x];
                emit BidToppedUp(
                    SaleIndex,
                    BidIndexes[x],
                    Amounts[x],
                    block.timestamp,
                    msg.sender
                );
            }
        }
        require(msg.value >= Total, "EnglishAuction: Invalid ETH Values");
        uint Rebate = msg.value - Total; // Rebates Excess ETH (If Total > msg.value This Will Revert)
        if (Rebate > 0) {
            (bool Success, ) = msg.sender.call{value: Rebate}("");
            require(
                Success,
                "EnglishAuction: Failed To Rebate Excess ETH To Bidder, Resubmit Transaction"
            );
            emit BidTopupRefunded(Rebate);
        }
    }

    /**
     * @dev Rebates ETH From Bid(s) If Bidder Is Not A Winner & Disperses NFTs If Winner
     * @param SaleIndex The Sale Index To Finalize
     */
    function UserSettleAuction(uint SaleIndex) external nonReentrant {
        require(
            tx.origin == msg.sender,
            "EnglishAuction: EOA Only, Use `delegate.cash` For Wallet Delegation"
        ); // Requires `msg.sender` Is A Valid EOA
        require(
            !SaleState[SaleIndex]._NFTsDispersed,
            "EnglishAuction: NFTs Have Been Dispersed"
        );
        require(
            AuctionParams[SaleIndex]._UserSettlementEnabled,
            "EnglishAuction: User Settlement Is Not Enabled"
        );
        require(
            UserBidIndexes[SaleIndex][msg.sender].length > 0,
            "EnglishAuction: User Has No Bids To Settle"
        );
        require(
            block.timestamp > AuctionParams[SaleIndex]._UnixEndTime,
            "EnglishAuction: Cannot Finalize, Auction Is Still Active"
        );
        address Bidder = msg.sender;
        __UserDisperseETH(SaleIndex, Bidder);
        __UserDisperseNFT(SaleIndex, Bidder);
    }

    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/

    /**
     * @dev Starts Auction
     * @param AuctionInfo The Struct Of Auction Info
     * @param RootsEligibility The Merkle Roots For Priority Eligibility
     * @param RootsAmounts The Merkle Roots For Priority Allocation
     * @param DiscountAmounts The Discount Amounts For The Auction ([80,90,95] = 20% Discount, 10% Discount, 5% Discount)
     */
    function _StartAuction(
        Params memory AuctionInfo,
        bytes32[] calldata RootsEligibility,
        bytes32[] calldata RootsAmounts,
        uint[] calldata DiscountAmounts
    ) external onlyOperator returns (uint SaleIndex) {
        // require(AuctionInfo._UnixStartTime >= block.timestamp, "EnglishAuction: Start Time Must Be In The Future");
        require(
            RootsEligibility.length == RootsAmounts.length &&
                RootsAmounts.length == DiscountAmounts.length,
            "EnglishAuction: Array Lengths Must Match"
        );
        require(
            AuctionInfo._MinBIPSIncrease >= 100,
            "EnglishAuction: Minimum BIPS Increase Must Be >= 100"
        );
        SaleIndex = _GLOBAL_UNIQUE_SALES;
        AuctionParams[SaleIndex] = AuctionInfo;
        SaleState[SaleIndex]._LastMinBid = AuctionParams[SaleIndex]
            ._InitialMinimumBid;
        SaleState[SaleIndex]._Active = true;
        Discounts[SaleIndex] = DiscountAmounts;
        MerkleRootsEligibility[SaleIndex] = RootsEligibility;
        MerkleRootsAmounts[SaleIndex] = RootsAmounts;
        _GLOBAL_UNIQUE_SALES = SaleIndex + 1;
        for (uint x; x < DiscountAmounts.length; x++) {
            require(
                DiscountAmounts[x] <= 100 && DiscountAmounts[x] > 0,
                "Invalid Discount Amounts"
            );
        }
        emit SaleStarted(SaleIndex);
        return SaleIndex;
    }

    /**
     * @dev Changes The Sale Roots
     * @param SaleIndex The Sale Index To Change
     * @param RootsEligibility The New Merkle Roots For Priority Eligibility
     * @param RootsAmounts The New Merkle Roots For Max Priority Allocation
     */
    function _ChangeRoots(
        uint SaleIndex,
        bytes32[] calldata RootsEligibility,
        bytes32[] calldata RootsAmounts
    ) external onlyOperator {
        MerkleRootsEligibility[SaleIndex] = RootsEligibility;
        MerkleRootsAmounts[SaleIndex] = RootsAmounts;
    }

    /**
     * @dev Changes The Sale Discounts
     * @param SaleIndex The Sale Index To Change
     * @param NewDiscountAmounts The New Discount Amounts To Change
     * note: True Discount Amount = 100 - DiscountAmounts[x] eg. (DiscountAmounts[80,90,95] = 20% Discount, 10% Discount, 5% Discount)
     */
    function _ChangeDiscountAmounts(
        uint SaleIndex,
        uint[] calldata NewDiscountAmounts
    ) external onlyOperator {
        for (uint x; x < NewDiscountAmounts.length; x++) {
            require(
                NewDiscountAmounts[x] <= 100 && NewDiscountAmounts[x] > 0,
                "Invalid Discount Amounts"
            );
        }
        Discounts[SaleIndex] = NewDiscountAmounts;
    }

    /**
     * @dev Changes The Mint Pack Amount
     */
    function _ChangeMintPackAmount(
        uint SaleIndex,
        uint NewAmount
    ) external onlyOperator {
        AuctionParams[SaleIndex]._MintPackAmount = NewAmount;
    }

    /**
     * @dev Changes The MintPass ProjectID
     * @param SaleIndex The Sale Index To Change
     * @param MintPassProjectID The New MintPass ProjectID To Change
     */
    function _ChangeMintPassProjectID(
        uint SaleIndex,
        uint MintPassProjectID
    ) external onlyOperator {
        AuctionParams[SaleIndex]._ProjectIDMintPass = MintPassProjectID;
    }

    /**
     * @dev Changes The Auction Global Pause State At `SaleIndex`
     * @param SaleIndex The Sale Index To Change
     */
    function _ChangeActiveState(uint SaleIndex) external onlyOperator {
        SaleState[SaleIndex]._Active = !SaleState[SaleIndex]._Active;
    }

    /**
     * @dev Changes Min Bid
     * @param SaleIndex The Sale Index To Change
     * @param NewMinBid The New Minimum Bid
     */
    function _ChangeMinBid(
        uint SaleIndex,
        uint NewMinBid
    ) external onlyOperator {
        SaleState[SaleIndex]._LastMinBid = NewMinBid;
    }

    /**
     * @dev Changes If The Lowest Valid Leaderboard Bid Is What Everyone Pays
     * @param SaleIndex The Sale Index To Change
     * @param NewState The New State (Boolean) (True = Everyone Pays Lowest Leaderboard Bid, False = Everyone Pays Their Bid ETH Value)
     */
    function _ChangeSettlementEnabled(
        uint SaleIndex,
        bool NewState
    ) external onlyOperator {
        AuctionParams[SaleIndex]._SettlementEnabled = NewState;
    }

    /**
     * @dev Changes The Bid Threshold (Controls The Leaderboard Size)
     * @param SaleIndex The Sale Index To Change
     * @param NewLeaderboardSize The New Leaderboard Size
     */
    function _ChangeLeaderboardSize(
        uint SaleIndex,
        uint NewLeaderboardSize
    ) external onlyOperator {
        AuctionParams[SaleIndex]._LeaderboardSize = NewLeaderboardSize;
    }

    /**
     * @dev Changes The Unix Start Time
     * @param SaleIndex The Sale Index To Change
     * @param NewUnixStartTime The New Unix Start Time
     */
    function _ChangeUnixStartTime(
        uint SaleIndex,
        uint NewUnixStartTime
    ) external onlyOperator {
        AuctionParams[SaleIndex]._UnixStartTime = NewUnixStartTime;
    }

    /**
     * @dev Changes The Unix End Time
     * @param SaleIndex The Sale Index To Change
     * @param NewUnixEndTime The New Unix End Time
     */
    function _ChangeUnixEndTime(
        uint SaleIndex,
        uint NewUnixEndTime
    ) external onlyOperator {
        AuctionParams[SaleIndex]._UnixEndTime = NewUnixEndTime;
    }

    /**
     * @dev Changes The Minimum BIPs Increase
     * @param SaleIndex The Sale Index To Change
     * @param NewMinBIPSIncrease The New Minimum BIPs Increase (In BIPS) (105 = 5% Increase, 150 = 50% Increase etc...)
     */
    function _ChangeMinBIPSIncrease(
        uint SaleIndex,
        uint NewMinBIPSIncrease
    ) external onlyOperator {
        require(
            NewMinBIPSIncrease >= 100,
            "EnglishAuction: Minimum BIPS Increase Must Be >= 100"
        );
        AuctionParams[SaleIndex]._MinBIPSIncrease = NewMinBIPSIncrease;
    }

    /**
     * @dev Changes The # Of Seconds The Auction Is Extended By If Auction End Time Is Within `AuctionParams[SaleIndex]._SecondsThreshold`
     * @param SaleIndex The Sale Index To Change
     * @param Seconds The New # Of Seconds To Extend Auction By
     */
    function _ChangeSecondsExtension(
        uint SaleIndex,
        uint Seconds
    ) external onlyOperator {
        AuctionParams[SaleIndex]._SecondsExtension = Seconds;
    }

    /**
     * @dev Changes The # Of Seconsd Within Auction End Time To Be Eligible For Auction Extension
     * @param SaleIndex The Sale Index To Change
     * @param Seconds The New # Of Seconds Within Auction End Time To Be Eligible For Auction Extension
     */
    function _ChangeSecondsThreshold(
        uint SaleIndex,
        uint Seconds
    ) external onlyOperator {
        AuctionParams[SaleIndex]._SecondsThreshold = Seconds;
    }

    /**
     * @dev Changes The Current NFT Address
     * @param SaleIndex The Sale Index To Change
     * @param NewAddress The New NFT Address
     */
    function _ChangeNFTAddress(
        uint SaleIndex,
        address NewAddress
    ) external onlyOperator {
        AuctionParams[SaleIndex]._NFT = NewAddress;
    }

    /**
     * @dev Changes The Current Operator Address (Address That Holds NFTs To Disperse)
     * @param SaleIndex The Sale Index To Change
     * @param Operator The New Operator Address (Address Holding NFTs To Disperse)
     */
    function _ChangeOperator(
        uint SaleIndex,
        address Operator
    ) external onlyOperator {
        AuctionParams[SaleIndex]._Operator = Operator;
    }

    /**
     * @dev Rebate All Discounts For Leaderboard Bids & Sends Remaining ETH To Multisig
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function _InitiateRebateAndProceeds(uint SaleIndex) external onlyOperator {
        SaleState[SaleIndex]._Active = false; // Ends Auction
        __AdminInitiateProceeds(SaleIndex); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard (First-Come-First-Serve) (When TokenID Is Ambiguous)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function _ProcessETHAndNFTsTokenIDsAmbiguous(
        uint SaleIndex
    ) external onlyOperator {
        SaleState[SaleIndex]._Active = false; // Ends Auction
        __AdminInitiateProceeds(SaleIndex); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __DisperseNFTsByFCFSAmbiguous(SaleIndex); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard (Ascending Ranking) (When TokenID Matters)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function _ProcessETHAndNFTsTokenIDsDistinct(
        uint SaleIndex
    ) external onlyOperator {
        SaleState[SaleIndex]._Active = false; // Ends Auction
        __AdminInitiateProceeds(SaleIndex); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __DisperseNFTsByAscendingRank(SaleIndex); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Specific TokenIDs (Ascending Ranking)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     * @param TokenIDs The TokenIDs To Disperse
     */
    function _ProcessETHAndNFTsTokenIDsSpecificRanked(
        uint SaleIndex,
        uint[] calldata TokenIDs
    ) external onlyOperator {
        SaleState[SaleIndex]._Active = false; // Ends Auction
        __AdminInitiateProceeds(SaleIndex); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __DisperseNFTsByUniqueTokenIDsAscending(SaleIndex, TokenIDs); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Mint Pack Amounts (Ascending Ranking)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function _ProcessETHAndNFTsMintPacksRanked(
        uint SaleIndex
    ) external onlyOperator {
        SaleState[SaleIndex]._Active = false; // Ends Auction
        __AdminInitiateProceeds(SaleIndex); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __DisperseNFTsMintPacks(SaleIndex); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     * @notice This Is A Safety Function To Prevent Ether Locking, Only Use In An Emergency
     */
    function __WithdrawETHToMultisig() external onlyAdmin {
        (bool Success, ) = _BRT_MULTISIG.call{value: address(this).balance}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /*------------------
     * OWNER FUNCTIONS *
    -------------------*/

    /**
     * @dev Initiates Withdrawl Proceeds
     */
    function ___WithdrawETH() external onlyOwner {
        (bool Success, ) = msg.sender.call{value: address(this).balance}("");
        require(
            Success,
            "EnglishAuction: Unable to Withdraw, Recipient May Have Reverted"
        );
    }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Calculates The Minimum Valid Bid And Seeds The Leaderboard
     * @param SaleIndex The Sale Index To Calculate The Minimum Valid Bid For
     * @param MsgValue The Message Value (In WEI) To Calculate The Minimum Valid Bid For
     */
    function __FinalizeNewBid(uint SaleIndex, uint MsgValue) internal {
        (uint MinBid, uint LeaderboardIndex) = _ViewMinimumValidBidAndIndex(
            SaleIndex
        );
        require(
            MsgValue >= MinBid,
            "EnglishAuction: Bid Amount Must Be >= Current Leaderboard Floor * 1.05"
        ); // Requires Min Bid
        bool Valid = (SaleState[SaleIndex]._GlobalUniqueBids >=
            AuctionParams[SaleIndex]._LeaderboardSize);
        if (Valid) {
            __KickbackETH(SaleIndex, LeaderboardIndex); // Rebate ETH To Previous Bidder
            SaleState[SaleIndex]._LastMinBid = MinBid; // Stores Minimum Bid
        }
        Leaderboard[SaleIndex][LeaderboardIndex] = SaleState[SaleIndex]
            ._GlobalUniqueBids; // Kicks Old Bid Index Out Of Leaderboard
    }

    /**
     * @dev Kicks Losing Bidder's ETH Back To Them
     * @param SaleIndex The Sale Index To Trigger Disbursement
     * @param LeaderboardIndex The Leaderboard Index To Kickback ETH To
     */
    function __KickbackETH(uint SaleIndex, uint LeaderboardIndex) internal {
        if (
            !Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]._Rebated
        ) {
            Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]
                ._Rebated = true;
            (bool Success, ) = Bids[SaleIndex][
                Leaderboard[SaleIndex][LeaderboardIndex]
            ]._Bidder.call{
                value: Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]
                    ._ETHValue
            }("");
            require(Success, "EnglishAuction: Kickback Failed");
            emit BidRefunded(
                Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]
                    ._OGBidIndex
            );
        }
    }

    /**
     * @dev Finalizes ETH From User's Pending Bid(s)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     * @param Bidder The Bidder To Disperse ETH To
     */
    function __UserDisperseETH(uint SaleIndex, address Bidder) internal {
        uint[] memory _UserBidIndexes = UserBidIndexes[SaleIndex][Bidder];
        uint LLB = _ViewLowestLeaderboardBid(SaleIndex);
        uint TotalRebate;
        uint TotalPaid;
        uint CurrentRebate;
        uint CurrentPaid;
        uint Discount;
        for (uint x; x < UserBidIndexes[SaleIndex][Bidder].length; x++) {
            if (
                !Bids[SaleIndex][_UserBidIndexes[x]]._Winner && // Bid Is Not Winner
                !Bids[SaleIndex][_UserBidIndexes[x]]._Rebated && // Bid Has Not Been Rebated
                Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue >= LLB // Bid Is Valid ETH Value
            ) {
                Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]
                    ._Winner = true;
                Bids[SaleIndex][_UserBidIndexes[x]]._Rebated = true;
                if (Bids[SaleIndex][_UserBidIndexes[x]]._Priority == 69420) {
                    Discount = 100;
                } else {
                    Discount = Discounts[SaleIndex][
                        Bids[SaleIndex][_UserBidIndexes[x]]._Priority
                    ];
                }
                if (AuctionParams[SaleIndex]._SettlementEnabled) {
                    CurrentRebate =
                        Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue -
                        ((LLB * Discount) / 100);
                    CurrentPaid =
                        Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue -
                        CurrentRebate;
                    TotalRebate += CurrentRebate;
                } else {
                    CurrentPaid = Bids[SaleIndex][_UserBidIndexes[x]]._ETHValue;
                }
                TotalPaid += (CurrentPaid * Discount) / 100;
            }
        }
        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call{value: TotalPaid}("");
        require(MultisigWithdraw, "EnglishAuction: Multisig Withdraw Failed");
        if (TotalRebate > 0) {
            (bool UserWithdraw, ) = Bidder.call{value: TotalRebate}("");
            require(UserWithdraw, "EnglishAuction: User Rebate Failed");
        }
    }

    /**
     * @dev Disperses NFTs
     * @param SaleIndex The Sale Index To Trigger Disbursement
     * @param Bidder The Bidder To Disperse NFTs To
     */
    function __UserDisperseNFT(uint SaleIndex, address Bidder) internal {
        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);
        for (uint x; x < UserBidIndexes[SaleIndex][Bidder].length; x++) {
            if (
                Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]._Winner &&
                !Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]._NFTSent
            ) {
                Bids[SaleIndex][UserBidIndexes[SaleIndex][Bidder][x]]
                    ._NFTSent = true;
                _NFT._MintToFactory(Bidder, 1);
            }
        }
    }

    /**
     * @dev Initiates Proceeds From The Leaderboard
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function __AdminInitiateProceeds(uint SaleIndex) internal {
        if (
            AuctionParams[SaleIndex]._LeaderboardSize >
            SaleState[SaleIndex]._GlobalUniqueBids
        ) {
            AuctionParams[SaleIndex]._LeaderboardSize = SaleState[SaleIndex]
                ._GlobalUniqueBids; // If Sale Did Not Sell Out, Sets Leaderboard Size To # Of Bids
        }
        uint TotalProceeds;
        uint LLB = _ViewLowestLeaderboardBid(SaleIndex);
        uint RebateAmount;
        uint Discount;
        uint Priority;
        uint ETHValue;
        for (uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) {
            if (
                !Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Rebated &&
                !Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Winner &&
                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue >= LLB
            ) {
                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Winner = true;
                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Rebated = true;
                Priority = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Priority;
                ETHValue = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue;
                if (Priority == 69420) {
                    Discount = 100;
                }
                // No Merkle Priority
                else {
                    Discount = Discounts[SaleIndex][Priority];
                } // Merkle Priority
                if (AuctionParams[SaleIndex]._SettlementEnabled) {
                    RebateAmount = ETHValue - ((LLB * Discount) / 100);
                } else {
                    RebateAmount = ETHValue - ((ETHValue * Discount) / 100);
                }
                if (RebateAmount > 0) {
                    (bool Rebate, ) = Bids[SaleIndex][Leaderboard[SaleIndex][x]]
                        ._Bidder
                        .call{value: RebateAmount}("");
                    require(
                        Rebate,
                        "EnglishAuction: Failed To Rebate ETH To Bidder, Use Failsafe Withdraw"
                    );
                }
                TotalProceeds += (ETHValue - RebateAmount);
            }
        }
        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call{value: TotalProceeds}(
            ""
        );
        require(
            MultisigWithdraw,
            "EnglishAuction: Failed To Withdraw ETH To Multisig, Use Failsafe Withdraw"
        );
    }

    /**
     * @dev Validates The Auction End Time & Extends If Necessary
     * @param SaleIndex The Sale Index To Check
     */
    function __CheckAndSeedAuctionEndTime(uint SaleIndex) internal {
        // Extends Auction If Rebate Last Price (Settlement Price) Is Not Enabled (For Sales Where Leaderboard Placement Matters)
        if (
            (AuctionParams[SaleIndex]._UnixEndTime - block.timestamp) <
            AuctionParams[SaleIndex]._SecondsThreshold
        ) // If Bid Placed In Last 5 Minutes
        {
            AuctionParams[SaleIndex]._UnixEndTime =
                block.timestamp +
                AuctionParams[SaleIndex]._SecondsExtension; // Extends Auction By The # Of Configured Seconds
            emit AuctionExtended();
        }
    }

    /**
     * @dev Disperses NFTs With Unique TokenIDs
     * @param SaleIndex The Sale Index To Trigger Disbursement
     * @param TokenIDs Array Of TokenIDs To Be Dispersed
     */
    function __DisperseNFTsByUniqueTokenIDsAscending(
        uint SaleIndex,
        uint[] calldata TokenIDs
    ) internal {
        require(
            !SaleState[SaleIndex]._Active,
            "EnglishAuction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First"
        );
        require(
            !SaleState[SaleIndex]._NFTsDispersed,
            "EnglishAuction: NFTs Already Dispersed"
        );
        require(
            TokenIDs.length == AuctionParams[SaleIndex]._LeaderboardSize,
            "EnglishAuction: TokenIDs Array Length Must Match Leaderboard Size"
        );
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);
        address _Op = AuctionParams[SaleIndex]._Operator;
        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);
        for (uint x; x < TokenIDs.length; x++) {
            require(
                !NFTTokenIDHasBeenSent[SaleIndex][TokenIDs[x]],
                "EnglishAuction: TokenID Already Sent"
            );
            NFTTokenIDHasBeenSent[SaleIndex][TokenIDs[x]] = true;
            _NFT.transferFrom(
                _Op,
                Bids[SaleIndex][_Ind[x]]._Bidder,
                TokenIDs[x]
            );
        }
    }

    /**
     * @dev Disperses NFTs To The Top Bidders On The Leaderboard (First-Come-First-Serve) (Use When TokenID Is Ambiguous)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function __DisperseNFTsByFCFSAmbiguous(uint SaleIndex) internal {
        require(
            !SaleState[SaleIndex]._Active,
            "EnglishAuction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First"
        );
        require(
            !SaleState[SaleIndex]._NFTsDispersed,
            "EnglishAuction: NFTs Already Dispersed"
        );
        SaleState[SaleIndex]._NFTsDispersed = true;
        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);
        for (uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) {
            if (
                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Winner &&
                !Bids[SaleIndex][Leaderboard[SaleIndex][x]]._NFTSent
            ) {
                Bids[SaleIndex][Leaderboard[SaleIndex][x]]._NFTSent = true;
                _NFT._MintToFactory(
                    Bids[SaleIndex][Leaderboard[SaleIndex][x]]._Bidder,
                    1
                );
            }
        }
    }

    /**
     * @dev Disperses NFTs By Ascending Ranking Of The Leaderboard (Use When TokenID Matters)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function __DisperseNFTsByAscendingRank(uint SaleIndex) internal {
        require(
            SaleState[SaleIndex]._Active == false,
            "EnglishAuction: Auction Is Still Active, Must Disperse Funds First"
        );
        require(
            !SaleState[SaleIndex]._NFTsDispersed,
            "EnglishAuction: NFTs Already Dispersed"
        );
        SaleState[SaleIndex]._NFTsDispersed = true;
        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);
        for (uint x; x < _Ind.length; x++) {
            if (
                Bids[SaleIndex][_Ind[x]]._Winner &&
                !Bids[SaleIndex][_Ind[x]]._NFTSent
            ) {
                Bids[SaleIndex][_Ind[x]]._NFTSent = true;
                _NFT._MintToFactory(Bids[SaleIndex][_Ind[x]]._Bidder, 1);
            }
        }
    }

    /**
     * @dev Disperses NFTs To The Top Bidders On The Leaderboard (With Mint Pack Amounts) (With Ranking Enabled)
     * @param SaleIndex The Sale Index To Trigger Disbursement
     */
    function __DisperseNFTsMintPacks(uint SaleIndex) internal {
        require(
            !SaleState[SaleIndex]._Active,
            "EnglishAuction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First"
        );
        require(
            !SaleState[SaleIndex]._NFTsDispersed,
            "EnglishAuction: NFTs Already Dispersed"
        );
        require(
            AuctionParams[SaleIndex]._MintPackAmount > 1,
            "EnglishAuction: Mint Pack Amount Must Be > 1"
        );
        SaleState[SaleIndex]._NFTsDispersed = true;
        IERC721 _NFT = IERC721(AuctionParams[SaleIndex]._NFT);
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);
        uint _MintPackAmount = AuctionParams[SaleIndex]._MintPackAmount;
        for (uint x; x < _Ind.length; x++) {
            if (
                Bids[SaleIndex][_Ind[x]]._Winner &&
                !Bids[SaleIndex][_Ind[x]]._NFTSent
            ) {
                Bids[SaleIndex][_Ind[x]]._NFTSent = true;
                _NFT._MintToFactory(
                    Bids[SaleIndex][_Ind[x]]._Bidder,
                    _MintPackAmount
                );
            }
        }
    }

    /*------------------------
     * PUBLIC VIEW FUNCTIONS *
    -------------------------*/

    /**
     * @dev Returns All Necessary Leaderboard Components
     * @param SaleIndex The Sale Index To View
     * @param Wallet The Wallet Address Of The Bidder ('0x0000000000000000000000000000000000000000') If No Wallet
     * @return _LowestLeaderboardBid The Lowest Current Leaderboard Bid
     * @return _MinimumNewBid The Minimum Viable Bid That Can Be Submitted To The Auction
     * @return _AuctionParams The Auction Parameters
     * @return _RankedLeaderboard The Ranked Leaderboard
     * @return _UserBidIndexes The Bid Indexes Of The User
     * @return _DiscountAmounts The Discount Amounts For Brightlist Priority Tiers ([80,90,95] = 20% Discount, 10% Discount, 5% Discount)
     * @return _MerkleRootsEligibility The Merkle Roots For Priority Eligibility
     * @return _MerkleRootsAmounts The Merkle Roots For Priority Allocation
     */
    function ViewFrontend(
        uint SaleIndex,
        address Wallet
    )
        public
        view
        returns (
            uint _LowestLeaderboardBid,
            uint _MinimumNewBid,
            AllAuctionParams memory _AuctionParams,
            Bid[] memory _RankedLeaderboard,
            uint[] memory _UserBidIndexes,
            uint[] memory _DiscountAmounts,
            bytes32[] memory _MerkleRootsEligibility,
            bytes32[] memory _MerkleRootsAmounts
        )
    {
        uint LLB = _ViewLowestLeaderboardBid(SaleIndex);
        _RankedLeaderboard = _ViewLeaderboardRanked(SaleIndex);
        uint MVB = (LLB * (AuctionParams[SaleIndex]._MinBIPSIncrease)) / 100;
        if (
            SaleState[SaleIndex]._GlobalUniqueBids <
            AuctionParams[SaleIndex]._LeaderboardSize
        ) {
            (LLB, MVB) = (
                SaleState[SaleIndex]._LastMinBid,
                SaleState[SaleIndex]._LastMinBid
            );
        }
        return (
            LLB,
            MVB,
            ViewAuctionParams(SaleIndex),
            ViewLeaderboardRanked(SaleIndex),
            UserBidIndexes[SaleIndex][Wallet],
            Discounts[SaleIndex],
            MerkleRootsEligibility[SaleIndex],
            MerkleRootsAmounts[SaleIndex]
        );
    }

    /**
     * @dev Returns All Bid Values In The Leaderboard
     * @param SaleIndex The Sale Index To View
     */
    function ViewLeaderboardBids(
        uint SaleIndex
    ) public view returns (uint[] memory) {
        uint[] memory _Indexes = ViewLeaderboardIndexes(SaleIndex);
        uint[] memory _BidValues = new uint[](
            AuctionParams[SaleIndex]._LeaderboardSize
        );
        for (uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) {
            _BidValues[x] = Bids[SaleIndex][_Indexes[x]]._ETHValue;
        }
        return _BidValues;
    }

    /**
     * @dev Returns A Bid Array Of Ranked Top Bids
     * @param SaleIndex The Sale Index To View
     */
    function ViewLeaderboardRanked(
        uint SaleIndex
    ) public view returns (Bid[] memory) {
        return _ViewLeaderboardRanked(SaleIndex);
    }

    /**
     * @dev Returns All Bid Indexes In The Leaderboard
     * @param SaleIndex The Sale Index To View
     */
    function ViewLeaderboardIndexes(
        uint SaleIndex
    ) public view returns (uint[] memory) {
        uint[] memory _LeaderboardIndexes = new uint[](
            AuctionParams[SaleIndex]._LeaderboardSize
        );
        for (uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) {
            _LeaderboardIndexes[x] = Leaderboard[SaleIndex][x];
        }
        return _LeaderboardIndexes;
    }

    /**
     * @dev Returns The Minimum Valid Bid
     * @param SaleIndex The Sale Index To View
     */
    function ViewMinimumValidBid(
        uint SaleIndex
    ) public view returns (uint ValidBid) {
        (ValidBid, ) = _ViewMinimumValidBidAndIndex(SaleIndex);
        return ValidBid;
    }

    /**
     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes
     * @param SaleIndex The Sale Index To View
     */
    function ViewBidsUnique(uint SaleIndex) public view returns (Bid[] memory) {
        Bid[] memory _Bids = new Bid[](SaleState[SaleIndex]._GlobalUniqueBids);
        for (uint x; x < SaleState[SaleIndex]._GlobalUniqueBids; x++) {
            _Bids[x] = Bids[SaleIndex][x];
        }
        return _Bids;
    }

    /**
     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes
     * @param SaleIndex The Sale Index To View
     * @param Indexes The Indexes To Return
     */
    function ViewBidsAtIndexes(
        uint SaleIndex,
        uint[] calldata Indexes
    ) public view returns (Bid[] memory) {
        Bid[] memory _Bids = new Bid[](Indexes.length);
        for (uint x; x < Indexes.length; x++) {
            _Bids[x] = Bids[SaleIndex][Indexes[x]];
        }
        return _Bids;
    }

    /**
     * @dev Returns A `Bid` Struct Array Of All Unique Bids In The Auction Submitted By `Wallet`
     * @param SaleIndex The Sale Index To View
     * @param Wallet The Wallet Address To View
     */
    function ViewWalletBids(
        uint SaleIndex,
        address Wallet
    ) public view returns (Bid[] memory) {
        uint[] memory _Indexes = UserBidIndexes[SaleIndex][Wallet];
        Bid[] memory _Bids = new Bid[](_Indexes.length);
        for (uint x; x < _Indexes.length; x++) {
            _Bids[x] = Bids[SaleIndex][_Indexes[x]];
        }
        return _Bids;
    }

    /**
     * @dev Returns An Array Of `Wallet` Submitted Bid Indexes
     * @param SaleIndex The Sale Index To View
     * @param Wallet The Wallet Address To View
     */
    function ViewWalletBidIndexes(
        uint SaleIndex,
        address Wallet
    ) public view returns (uint[] memory) {
        return UserBidIndexes[SaleIndex][Wallet];
    }

    /**
     * @dev Returns All Of The Current Auction Parameters
     * @param SaleIndex The Sale Index To View
     */
    function ViewAuctionParams(
        uint SaleIndex
    ) public view returns (AllAuctionParams memory) {
        return
            AllAuctionParams(
                AuctionParams[SaleIndex]._Name,
                SaleState[SaleIndex]._Active,
                SaleState[SaleIndex]._NFTsDispersed,
                AuctionParams[SaleIndex]._SettlementEnabled,
                AuctionParams[SaleIndex]._LeaderboardSize,
                AuctionParams[SaleIndex]._UnixStartTime,
                AuctionParams[SaleIndex]._UnixEndTime,
                AuctionParams[SaleIndex]._MinBIPSIncrease,
                AuctionParams[SaleIndex]._SecondsExtension,
                AuctionParams[SaleIndex]._SecondsThreshold,
                SaleState[SaleIndex]._LastMinBid,
                SaleState[SaleIndex]._GlobalUniqueBids,
                AuctionParams[SaleIndex]._ProjectIDMintPass,
                AuctionParams[SaleIndex]._MintPackAmount,
                AuctionParams[SaleIndex]._NFT
            );
    }

    /**
     * @dev Returns Merkle Roots For A Specific Sale
     * @param SaleIndex The Sale Index To View
     */
    function ViewRoots(uint SaleIndex) public view returns (bytes32[] memory) {
        return MerkleRootsEligibility[SaleIndex];
    }

    /*--------------------------
     * INTERNAL VIEW FUNCTIONS *
    ---------------------------*/

    /**
     * @dev Validates Merkle Proof And Returns Merkle Priority
     * @param SaleIndex The Sale Index To View
     * @param MaxAmount The Maximum Allocation For Merkle Priority
     * @param Bidder The Bidder To Validate
     * @param ProofEligibility The Merkle Proof To Validate For Priority Eligibilty Tier
     * @param ProofAmount The Merkle Proof To Validate For Maximum Merkle Amount
     */
    function _ValidateMerkleProofs(
        uint SaleIndex,
        uint MaxAmount,
        address Bidder,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) internal view returns (uint) {
        bytes32 Leaf = keccak256(abi.encodePacked(Bidder));
        for (
            uint Priority;
            Priority < Discounts[SaleIndex].length;
            Priority++
        ) {
            if (
                MerkleProof.verify(
                    ProofEligibility,
                    MerkleRootsEligibility[SaleIndex][Priority],
                    Leaf
                )
            ) {
                require(
                    MerkleProof.verify(
                        ProofAmount,
                        MerkleRootsAmounts[SaleIndex][Priority],
                        keccak256(abi.encodePacked(Bidder, MaxAmount))
                    ),
                    "EnglishAuction: Invalid Merkle Amount"
                );
                return (Priority); // Returns Valid Priority
            }
        }
        return (69420); // Returns Default Out Of Bounds Priority
    }

    /**
     * @dev Returns The Leaderboard Index Of The Smallest Bid In The Leaderboard
     * @param SaleIndex The Sale Index To View
     */
    function _ViewMinimumValidLeaderboardIndex(
        uint SaleIndex
    ) internal view returns (uint) {
        uint CurrentMinBid = type(uint).max;
        uint LeaderboardIndexToReplace;
        uint ETHValue;
        if (
            SaleState[SaleIndex]._GlobalUniqueBids <
            AuctionParams[SaleIndex]._LeaderboardSize
        ) {
            return SaleState[SaleIndex]._GlobalUniqueBids;
        }
        for (
            uint IndexLeaderboard;
            IndexLeaderboard < AuctionParams[SaleIndex]._LeaderboardSize;
            IndexLeaderboard++
        ) {
            ETHValue = Bids[SaleIndex][Leaderboard[SaleIndex][IndexLeaderboard]]
                ._ETHValue;
            if (ETHValue <= CurrentMinBid) {
                CurrentMinBid = ETHValue;
                LeaderboardIndexToReplace = IndexLeaderboard;
            }
        }
        return LeaderboardIndexToReplace;
    }

    /**
     * @dev Returns The Lowest Bid In The Leaderboard
     * @param SaleIndex The Sale Index To View
     */
    function _ViewLowestLeaderboardBid(
        uint SaleIndex
    ) internal view returns (uint LLB) {
        LLB = type(uint).max;
        for (uint x; x < AuctionParams[SaleIndex]._LeaderboardSize; x++) {
            if (Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue < LLB) {
                LLB = Bids[SaleIndex][Leaderboard[SaleIndex][x]]._ETHValue;
            }
        }
        return LLB;
    }

    /**
     * @dev Returns The Minimum Valid Bid Which Is The Current Lowest Bid In The Leaderboard * 1.05
     * @param SaleIndex The Sale Index To View
     */
    function _ViewMinimumValidBidAndIndex(
        uint SaleIndex
    ) internal view returns (uint, uint) {
        uint LeaderboardIndex = _ViewMinimumValidLeaderboardIndex(SaleIndex);
        return (
            SaleState[SaleIndex]._GlobalUniqueBids <
                AuctionParams[SaleIndex]._LeaderboardSize // If Unique Bids Less Than LeaderboardSize Return NewMinimumBid & Eligible LeaderboardIndex
                ? (SaleState[SaleIndex]._LastMinBid, LeaderboardIndex) // Else Return NewMinimumBid & Eligible LeaderboardIndex
                : (
                    (Bids[SaleIndex][Leaderboard[SaleIndex][LeaderboardIndex]]
                        ._ETHValue *
                        AuctionParams[SaleIndex]._MinBIPSIncrease) / 100,
                    LeaderboardIndex
                )
        );
    }

    /**
     * @dev Returns A 'Bid' Struct Array Of All Unique Bids In The Auction
     * @param SaleIndex The Sale Index To View
     * note: this will throw `out of gas` after 1648~ unique bids because block gas limit is 30M, use `ViewBids()` with indexes after 1648~ unique bids
     */
    function _ViewBidsUnique(
        uint SaleIndex
    ) internal view returns (Bid[] memory) {
        uint GlobalUniqueBids = SaleState[SaleIndex]._GlobalUniqueBids;
        Bid[] memory _Bids = new Bid[](GlobalUniqueBids);
        for (uint x; x < GlobalUniqueBids; x++) {
            _Bids[x] = Bids[SaleIndex][x];
        }
        return _Bids;
    }

    /**
     * @dev Returns A Bid Array Of Ranked Top Bids
     * @param SaleIndex The Sale Index To View
     */
    function _ViewLeaderboardRanked(
        uint SaleIndex
    ) internal view returns (Bid[] memory) {
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes(SaleIndex);
        Bid[] memory _Leaderboard = new Bid[](_Ind.length);
        for (uint x; x < _Ind.length; x++) {
            _Leaderboard[x] = Bids[SaleIndex][_Ind[x]];
        }
        return _Leaderboard;
    }

    /**
     * @dev Returns A Sorted List Of ETH Bids @ '[n][0]' & The Indexes Of The Original Bids @ '[n][1]' & The Timestamps @ '[n][2]'
     * @param SaleIndex The Sale Index To View
     * note: This Will Give Priority To Earlier Bid Indexes & Timestamps
     * note: insertion sort O(n^2) seemed like best approach because english auction bids increase as auction progresses, otherwise quicksort prob better O(nlogn)
     * note: because block gas limit is 30M, this will `out-of-gas` dependant on how much sorting needs done if you have a more eloquent way of doing this hmu
     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes
     */
    function _ViewSortedLeaderboardBidIndexes(
        uint SaleIndex
    ) internal view returns (uint[] memory) {
        uint Size;
        if (
            SaleState[SaleIndex]._GlobalUniqueBids <
            AuctionParams[SaleIndex]._LeaderboardSize
        ) {
            Size = SaleState[SaleIndex]._GlobalUniqueBids;
        } else {
            Size = AuctionParams[SaleIndex]._LeaderboardSize;
        }
        uint[][] memory BidsAndIndexes = new uint[][](Size);
        for (uint x; x < BidsAndIndexes.length; x++) {
            BidsAndIndexes[x] = new uint[](3); // Init Sub-Array
            BidsAndIndexes[x][0] = Bids[SaleIndex][Leaderboard[SaleIndex][x]]
                ._ETHValue; // Assign [x][0] -> ETHValue
            BidsAndIndexes[x][1] = Leaderboard[SaleIndex][x]; // Assign [x][1] -> Original Index
            BidsAndIndexes[x][2] = Bids[SaleIndex][Leaderboard[SaleIndex][x]]
                ._Timestamp; // Assign [x][2] -> Timestamp
        }
        for (uint i; i < BidsAndIndexes.length; i++) {
            uint ETHValue = BidsAndIndexes[i][0]; // Preserve ETHValue
            uint OGBidIndex = BidsAndIndexes[i][1]; // Preserve OGBidIndex
            uint Timestamp = BidsAndIndexes[i][2]; // Preserve Timestamp
            uint j = i;
            while (j > 0 && BidsAndIndexes[j - 1][0] >= ETHValue) {
                if (
                    (BidsAndIndexes[j - 1][0] == ETHValue &&
                        BidsAndIndexes[j - 1][1] > OGBidIndex) ||
                    (BidsAndIndexes[j - 1][0] == ETHValue &&
                        BidsAndIndexes[j - 1][2] > Timestamp) // Preserve Lower Original Index // Or // Preserve Lower Timestamp
                ) {
                    break;
                }
                BidsAndIndexes[j][0] = BidsAndIndexes[j - 1][0]; // Move Larger Element To The Right
                BidsAndIndexes[j][1] = BidsAndIndexes[j - 1][1]; // Move OG Index
                BidsAndIndexes[j][2] = BidsAndIndexes[j - 1][2]; // Move Timestamp
                j--;
            }
            BidsAndIndexes[j][0] = ETHValue; // Insert ETHValue In Correct Location
            BidsAndIndexes[j][1] = OGBidIndex; // Insert OGBidIndex In Correct Location
            BidsAndIndexes[j][2] = Timestamp; // Insert Timestamp In Correct Location
        }
        uint[] memory SortedBidIndexes = new uint[](Size);
        for (uint y; y < BidsAndIndexes.length; y++) {
            SortedBidIndexes[Size - 1 - y] = BidsAndIndexes[y][1];
        }
        return SortedBidIndexes;
    }
}

/**
 * @dev Interface For ERC721 Contracts
 */
interface IERC721 {
    /**
     * @dev Mints A NFT From Custom Smart Contract Directly
     */
    function _MintToFactory(address Recipient, uint Amount) external;

    /**
     * @dev Transfers An Already Minted NFT
     */
    function transferFrom(address from, address to, uint tokenID) external;
}
